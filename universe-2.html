<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<title>River Raid 3D</title>
<style>
    body { margin: 0; overflow: hidden; background: #000; }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* =====================================================
   SCENE / CAMERA / RENDERER
===================================================== */

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x000000, 10, 120);

const camera = new THREE.PerspectiveCamera(
    70,
    window.innerWidth / window.innerHeight,
    0.1,
    500
);
camera.position.set(0, 10, 20);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* =====================================================
   LIGHTING (güzellik burada başlar)
===================================================== */

scene.add(new THREE.AmbientLight(0x404040, 1.5));

const dirLight = new THREE.DirectionalLight(0xffffff, 2);
dirLight.position.set(5, 20, 10);
scene.add(dirLight);

/* =====================================================
   PLAYER (uçak)
===================================================== */

const player = new THREE.Mesh(
    new THREE.ConeGeometry(0.7, 3, 12),
    new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 0.4,
        roughness: 0.3
    })
);
player.rotation.x = Math.PI / 2;
player.position.y = 1;
scene.add(player);

/* =====================================================
   RIVER
===================================================== */

const riverSegments = [];
for (let i = 0; i < 50; i++) {
    const segment = new THREE.Mesh(
        new THREE.PlaneGeometry(10, 10),
        new THREE.MeshStandardMaterial({
            color: 0x003366,
            metalness: 0.2,
            roughness: 0.8
        })
    );
    segment.rotation.x = -Math.PI / 2;
    segment.position.z = -i * 10;
    scene.add(segment);
    riverSegments.push(segment);
}

/* =====================================================
   BULLETS
===================================================== */

const bullets = [];

function shoot() {
    const bullet = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xffcc00 })
    );
    bullet.position.copy(player.position);
    scene.add(bullet);
    bullets.push(bullet);
}

/* =====================================================
   ENEMIES
===================================================== */

const enemies = [];

function spawnEnemy() {
    const enemy = new THREE.Mesh(
        new THREE.BoxGeometry(1.5, 1.5, 1.5),
        new THREE.MeshStandardMaterial({
            color: 0xff3333,
            metalness: 0.6,
            roughness: 0.2
        })
    );
    enemy.position.set(
        (Math.random() - 0.5) * 6,
        1,
        -120
    );
    scene.add(enemy);
    enemies.push(enemy);
}

setInterval(spawnEnemy, 1200);

/* =====================================================
   INPUT
===================================================== */

const keys = {};
window.addEventListener("keydown", e => {
    keys[e.code] = true;
    if (e.code === "Space") shoot();
});
window.addEventListener("keyup", e => keys[e.code] = false);

/* =====================================================
   GAME LOOP
===================================================== */

function animate() {
    requestAnimationFrame(animate);

    /* Player Movement */
    if (keys["ArrowLeft"]) player.position.x -= 0.3;
    if (keys["ArrowRight"]) player.position.x += 0.3;
    player.position.x = THREE.MathUtils.clamp(player.position.x, -4, 4);

    /* River Flow */
    riverSegments.forEach(seg => {
        seg.position.z += 0.6;
        if (seg.position.z > 10) seg.position.z = -490;
    });

    /* Bullets */
    bullets.forEach((b, i) => {
        b.position.z -= 1.2;
        if (b.position.z < -150) {
            scene.remove(b);
            bullets.splice(i, 1);
        }
    });

    /* Enemies */
    enemies.forEach((e, ei) => {
        e.position.z += 0.4;

        bullets.forEach((b, bi) => {
            if (b.position.distanceTo(e.position) < 1) {
                scene.remove(e);
                scene.remove(b);
                enemies.splice(ei, 1);
                bullets.splice(bi, 1);
            }
        });

        if (e.position.z > 20) {
            scene.remove(e);
            enemies.splice(ei, 1);
        }
    });

    renderer.render(scene, camera);
}

animate();

/* =====================================================
   RESIZE
===================================================== */

window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
